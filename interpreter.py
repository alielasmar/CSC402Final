from lexer import Lexer
from parser_1 import Parser
import ast


class Interpreter:
    def __init__(self, lexer, parser):
        self.lexer = lexer
        self.parser = parser
        self.symbols = {}
        self.functions = {}
        self.current_token = None
        self.peek_token = None
        self.advance()  # set up the current_token and peek_token

    def error(self, message):
        raise Exception(f"Error: {message}")

    def eat(self, token_type):
        if self.current_token.kind == token_type:
            self.advance()
        else:
            self.error(f"Expected {token_type}, but got {self.current_token.kind}")

    def factor(self):
        ...
        
    def term(self):
        ...
        
    def arithmetic_expr(self):
        ...
        
    def comparison_expr(self):
        ...
        
    def boolean_expr(self):
        ...
        
    def expr(self):
        ...
        
    def assignment_statement(self):
        ...
        
    def input_statement(self):
        ...
        
    def print_statement(self):
        ...
        
    def statement(self):
        ...
        
    def block(self):
        ...
        
    def function_definition(self):
        ...
    
    def run_prompt(self):
        while True:
            try:
                text = input('basic> ')
            except EOFError:
                break
            if not text:
                continue
            try:
                tokens = self.lexer.tokenize(text)
                ast = self.parser.parse(tokens)
                self.run_ast(ast)
            except (LexerError, ParserError, InterpreterError) as e:
                print(e)
        
    def run_file(self, file_name):
        with open(file_name, 'r') as f:
            program_text = f.read()
            self.parse(program_text)
            self.run()

    def parse(self, program_text):
        # Create the lexer and parser
        lexer = Lexer(program_text)
        parser = Parser(lexer)

        # Parse the program and build the AST
        self.program = parser.parse_program()
        if len(parser.errors) > 0:
            print("Parsing failed:")
            for error in parser.errors:
                print(error)
            return

        # Bind function names to function objects
        for function in self.program.functions.values():
            function_body = function.body
            function_name = function.name.value
            self.symbol_table[function_name] = function_body

    def run(self):
        if not self.program:
            print("No program to run")
            return

        # Execute each statement in the program
        for statement in self.program.statements:
            result = self.execute(statement)
            if isinstance(result, ReturnValue):
                return result.value
            elif isinstance(result, Error):
                return result.message
    
    def run_basic_program(self, input_string):
        # Create the lexer and parser
        lexer = Lexer(input_string)
        parser = Parser(lexer)

        # Parse the program
        program = parser.parse()

        # Evaluate the program
        global_vars = {}
        local_vars = {}
        program.eval(global_vars, local_vars)
        
    def print_token_stream(self):
        """
        Prints the list of tokens generated by the lexer.
        """
        for token in self.token_stream:
            print(token)
            
    def print_ast(self, ast_node, indent=0):
        """Prints the AST node in a human-readable format with indentation."""
        print(' ' * indent + str(ast_node))
        for child in ast_node.children:
            self.print_ast(child, indent + 2)
#Call with:
    #ast = self.build_ast()
    #self.print_ast(ast)

    def print_environment(self):
        for name, value in self.environment.items():
            print(name, "=", value)
            
    
    def evaluate_ast(self, node):
        if isinstance(node, ast.Number):
            return node.value
        elif isinstance(node, ast.String):
            return node.value
        elif isinstance(node, ast.Variable):
            return self.environment.get(node.name)
        elif isinstance(node, ast.Function):
            args = [self.evaluate_ast(arg) for arg in node.args]
            func = self.functions[node.name]
            return func(*args)
        elif isinstance(node, ast.BinaryOperator):
            left = self.evaluate_ast(node.left)
            right = self.evaluate_ast(node.right)
            if node.op == '+':
                return left + right
            elif node.op == '-':
                return left - right
            elif node.op == '*':
                return left * right
            elif node.op == '/':
                return left / right
            elif node.op == '^':
                return left ** right
            elif node.op == '<':
                return left < right
            elif node.op == '>':
                return left > right
            elif node.op == '<=':
                return left <= right
            elif node.op == '>=':
                return left >= right
            elif node.op == '==':
                return left == right
            elif node.op == '<>':
                return left != right
            else:
                raise Exception(f'Invalid operator: {node.op}')
        elif isinstance(node, ast.UnaryOperator):
            operand = self.evaluate_ast(node.operand)
            if node.op == '-':
                return -operand
            elif node.op == '+':
                return +operand
            else:
                raise Exception(f'Invalid operator: {node.op}')
        elif isinstance(node, ast.Assignment):
            value = self.evaluate_ast(node.value)
            self.environment[node.variable.name] = value
            return value
        else:
            raise Exception(f'Invalid AST node: {node}')